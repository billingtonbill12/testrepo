b"b'from lstore.bufferpool import Bufferpool\\nfrom lstore.page import Page\\nfrom lstore.config import *\\n\\nclass Range:\\n\\n    def __init__(self, num_columns, primary_key, table_name, range_number):\\n\\n        # set the number of columns\\n        self.num_columns = num_columns\\n\\n        # set the column number of the primary key\\n        self.primary_key = primary_key\\n\\n        # record the name of the table to which this range belongs\\n        self.table_name = table_name\\n\\n        # record the number in the list of ranges that corresponds to this range\\n        self.range_number = range_number\\n\\n        # set the number of records in this range\\n        self.num_records = 0\\n\\n        # note the currently filling base page\\n        self.current_base_page = -1\\n\\n        # currently filling tail page\\n        self.current_tail_page = -1\\n\\n        # generate an initial empty base page\\n        self.add_base_page()\\n        self.add_tail_page()\\n\\n    def add_base_record(self, columns):\\n        # update each of the columns\\n        for column_num in range(self.num_columns):\\n\\n            # get the most recent page\\n            page = Bufferpool().hold_base_page(self.table_name, self.range_number, column_num, self.current_base_page)\\n\\n            # if the page has no space to be written to\\n            if page.has_capacity() != True:\\n\\n                # release the currently held page since it is not the one that we want\\n                Bufferpool().release_base_page(self.table_name, self.range_number, column_num, self.current_base_page)\\n\\n                # then add a base page\\n                self.add_base_page()\\n\\n                # load the new empty base page\\n                page = Bufferpool().hold_base_page(self.table_name, self.range_number, column_num, self.current_base_page)\\n\\n            # write to it\\n            offset = page.write(columns[column_num])\\n\\n            # release the page after it is no longer needed\\n            Bufferpool().release_base_page(self.table_name, self.range_number, column_num, self.current_base_page)\\n        \\n        # increase the number of records\\n        self.num_records += 1\\n\\n        # return the offset and page number within the page range\\n        return self.current_base_page, offset\\n    \\n    def add_base_page(self):\\n\\n        # update the current base page value\\n        self.current_base_page += 1\\n\\n        # add a new base page which means one more page in each of the columns\\n        for column_num in range(self.num_columns):\\n\\n            # add a new base page\\n            Bufferpool().add_base_page(self.table_name, self.range_number, column_num, self.current_base_page)\\n    \\n    def read_base_record(self, base_page_number, offset):\\n\\n        # declare a variable to hold the record contents\\n        columns = []\\n\\n        # collect the value for each of the columns\\n        for column_num in range(self.num_columns):\\n\\n            # read the value from the correct page\\n            columns.append(Bufferpool().hold_base_page(self.table_name, self.range_number, column_num, base_page_number).read(offset))\\n            Bufferpool().release_base_page(self.table_name, self.range_number, column_num, base_page_number)\\n\\n        # return the full record\\n        return columns\\n\\n    def add_tail_record(self, columns):\\n        # update each of the columns\\n        for column_num in range(self.num_columns):\\n\\n            # get the most recent page\\n            page = Bufferpool().hold_tail_page(self.table_name, self.range_number, column_num, self.current_tail_page)\\n\\n            # if the page has no space to be written to\\n            if page.has_capacity() != True:\\n\\n                # release the currently held page since it is not the one that we want\\n                Bufferpool().release_tail_page(self.table_name, self.range_number, column_num, self.current_tail_page)\\n\\n                # then add a tail page\\n                self.add_tail_page()\\n\\n                # load the new empty tail page\\n                page = Bufferpool().hold_tail_page(self.table_name, self.range_number, column_num, self.current_tail_page)\\n\\n            # write to it\\n            offset = page.write(columns[column_num])\\n\\n            # release the page after it is no longer needed\\n            Bufferpool().release_tail_page(self.table_name, self.range_number, column_num, self.current_tail_page)\\n\\n        # return the offset and page number within the page range\\n        return self.current_tail_page, offset\\n\\n    def add_tail_page(self):\\n\\n        # update the current base page value\\n        self.current_tail_page += 1\\n\\n        # add a new base page which means one more page in each of the columns\\n        for column_num in range(self.num_columns):\\n\\n            # add a new tail page\\n            Bufferpool().add_tail_page(self.table_name, self.range_number, column_num, self.current_tail_page)\\n\\n\\n    def read_tail_record(self, tail_page_number, offset):\\n        # declare a variable to hold the record contents\\n        columns = []\\n\\n        # collect the value for each of the columns\\n        for column_num in range(self.num_columns):\\n\\n            # read the value from the correct page\\n            columns.append(Bufferpool().hold_tail_page(self.table_name, self.range_number, column_num, tail_page_number).read(offset))\\n            Bufferpool().release_tail_page(self.table_name, self.range_number, column_num, tail_page_number)\\n\\n        # return the full record\\n        return columns\\n\\n    def change_indirection(self, base_page_number, offset, value):\\n        page = Bufferpool().hold_base_page(self.table_name, self.range_number, INDIRECTION_COLUMN, base_page_number)\\n        page.write_at_offset(value, offset)\\n        Bufferpool().release_base_page(self.table_name, self.range_number, INDIRECTION_COLUMN, base_page_number)\\n        return True\\n    \\n    def change_schema_encoding(self, base_page_number, offset, value):\\n        page = Bufferpool().hold_base_page(self.table_name, self.range_number, SCHEMA_ENCODING_COLUMN, base_page_number)\\n        page.write_at_offset(value, offset)\\n        Bufferpool().release_base_page(self.table_name, self.range_number, SCHEMA_ENCODING_COLUMN, base_page_number)\\n        return True\\n\\n\\n    def has_capacity(self):\\n\\n        # returns true if there is capacity, false otherwise\\n        if self.num_records < 65536:\\n            return True\\n        \\n        else:\\n            return False\\n'"